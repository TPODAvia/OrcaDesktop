<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>RMF — Multi-Robot Global View</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous" defer></script>

    <style>
      :root {
        color-scheme: dark;
        /* dynamic sizing controlled by JS */
        --v-label-font-size: 15px; /* vertex label size (scaled by slider) */
        --v-label-pad-v: 4px;
        --v-label-pad-h: 8px;
      }

      html, body { height:100%; margin:0; }
      body { background:#0f1115; color:#e6edf3; font:14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }

      /* Top bar */
      #top {
        display:flex; gap:12px; align-items:center; padding:8px 12px;
        background:#161a22; border-bottom:1px solid #232a36; position:sticky; top:0; z-index:10;
      }
      .pill { padding:4px 8px; background:#222a36; border:1px solid #2f3744; border-radius:999px; white-space:nowrap; }
      .legend { display:flex; gap:10px; align-items:center; }
      .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
      .ok { background:#22c55e; } .stale { background:#a3a3a3; } .no { background:#ef4444; }

      /* Map */
      #map { width:100%; height: calc(100% - 72px); }

      /* Robot tooltip */
      .robot-label {
        background: rgba(17,22,31,.9); color:#e6edf3; border:1px solid #2a3240; padding:2px 6px; border-radius:6px; font-weight:600;
      }
      .leaflet-tooltip.robot-label { box-shadow:none; }

      /* Vertex label (grows with --v-label-font-size) */
      .leaflet-tooltip.v-label {
        background: rgba(0,0,0,.58);
        color:#f8fafc; border:1px solid #2a3240; border-radius:6px;
        font-weight:700;
        padding: var(--v-label-pad-v) var(--v-label-pad-h);
        font-size: var(--v-label-font-size);
      }

      /* Bottom bar */
      #bar {
        position:fixed; left:8px; bottom:8px; z-index:9999; display:flex; gap:8px; align-items:center; flex-wrap:wrap;
        background:#11161f; border:1px solid #2a3240; padding:6px 8px; border-radius:8px; font-size:12px;
      }
      #opacity, #size { width:120px; }
      button, select, input[type="range"] {
        padding:6px 10px; border-radius:8px; background:#263143; color:#e6edf3; border:1px solid #39465a; cursor:pointer;
      }
      button:hover { filter:brightness(1.1); }
      .badge { padding:2px 6px; background:#22314a; border:1px solid #2d3b52; border-radius:8px; }

      /* Popup menu for vertex (patrol only) */
      .menu {
        position:absolute; z-index:99999; min-width:180px; background:#11161f; color:#e6edf3;
        border:1px solid #2a3240; border-radius:10px; box-shadow:0 12px 30px rgba(0,0,0,.45);
        padding:8px; display:none;
      }
      .menu .row { display:flex; gap:8px; flex-wrap:wrap; }
      .menu button { flex:1; }

      /* Toast */
      #toast {
        position: fixed; left: 50%; transform: translateX(-50%);
        bottom: 18px; background:#1b2130; color:#e6edf3; border:1px solid #2a3240;
        padding:10px 14px; border-radius:10px; display:none; z-index:99999;
      }
    </style>
  </head>
  <body>
    <div id="top">
      <span class="pill" id="status">loading…</span>
      <span class="pill">zoom: wheel • pan: drag</span>
      <span class="legend"><span class="dot ok"></span> fix <span class="dot stale"></span> stale <span class="dot no"></span> no fix</span>
      <span class="pill" id="count">0 robots</span>
      <span class="pill" id="mapsInfo">maps: -</span>
      <span class="pill" id="overlayInfo">overlay: -</span>
      <span class="pill" id="selList">Selected: -</span>
    </div>

    <div id="map" aria-label="OpenStreetMap with robots and overlays"></div>

    <div id="bar">
      <label>ns <select id="nsSelect"></select></label>
      <button id="btnPublishPatrol" type="button">Publish patrol</button>
      <button id="btnClearSel" type="button">Clear</button>
      <button id="btnCancelAll" type="button">Cancel all</button>
      <button id="btnReturnHome" type="button">Return home</button>

      <span class="badge">overlay α</span>
      <input id="opacity" type="range" min="0" max="1" step="0.05" value="0.5"/>

      <span class="badge">size</span>
      <input id="size" type="range" min="0.6" max="2.5" step="0.1" value="1.4"/>
      <span id="sizeVal" class="pill">x1.4</span>

      <button id="btnCenterMap" type="button">Center</button>
    </div>

    <div id="toast"></div>

    <!-- Patrol-only vertex menu -->
    <div id="vmenu" class="menu" role="dialog" aria-modal="false">
      <div class="title" id="vmenuTitle" style="font-weight:700; margin-bottom:6px;">Vertex</div>
      <div class="row">
        <button id="actAddToPatrol">Add to patrol</button>
        <button id="actRemoveFromPatrol">Remove from patrol</button>
      </div>
    </div>

    <script>
      const DEBUG = true;
      function log(...a){ if(DEBUG) console.log('[UI]', ...a); }
      function warn(...a){ if(DEBUG) console.warn('[UI]', ...a); }
      function err(...a){ console.error('[UI]', ...a); }
      function setStatus(s){ const el=document.getElementById('status'); if(el) el.textContent=s; }
      function showToast(msg, ms=1600){ const t=document.getElementById('toast'); t.textContent=msg; t.style.display='block'; clearTimeout(showToast._t); showToast._t=setTimeout(()=>t.style.display='none', ms); }

      // ----- Sizing config (scaled at runtime) -----
      const BASE = Object.freeze({
        VERTEX_RADIUS: 6.5,       // bigger default vertex dot
        VERTEX_STROKE: 2,         // vertex outline thickness
        EDGE_WEIGHT:   3,         // graph edge thickness
        PATH_WEIGHT:   6,         // robot planned path thickness
        LABEL_FONT_PX: 15         // vertex label font size
      });
      let SIZE_SCALE = 1.4;       // default UI slider value

      function sizes(){
        return {
          VERTEX_RADIUS: Math.max(2, Math.round(BASE.VERTEX_RADIUS * SIZE_SCALE)),
          VERTEX_STROKE: Math.max(1, Math.round(BASE.VERTEX_STROKE * SIZE_SCALE)),
          EDGE_WEIGHT:   Math.max(1, Math.round(BASE.EDGE_WEIGHT * SIZE_SCALE)),
          PATH_WEIGHT:   Math.max(2, Math.round(BASE.PATH_WEIGHT * SIZE_SCALE)),
          LABEL_FONT_PX: Math.max(10, Math.round(BASE.LABEL_FONT_PX * SIZE_SCALE))
        };
      }

      let map, tiles;

      // robots
      const markers = new Map();

      // overlays per (ns|map|floor)
      const overlayGroups = new Map(); // key -> {img, verts, edges}
      let overlayAlpha = 0.5;

      // degraded caches
      let lastGoodRobots = { robots: [], t: 0 };
      let lastGoodMaps   = { maps: [],   t: 0 };

      let firstMapCenter = true;
      let lastMapsPayload = null;

      // ns + patrol selection
      let activeNs = '/';
      const selected = new Set();
      let selectedOrder = [];
      const nameToVertexMarker = new Map();

      // path cache
      const pathLayers = new Map(); // ns -> L.Polyline
      const lastPathSeq = new Map();

      // vertex popup state
      const vmenu = document.getElementById('vmenu');
      const vmenuTitle = document.getElementById('vmenuTitle');
      let vmenuFor = null; // {ns, name, lat, lon}

      function createMap(){
        if(!window.L){ err('Leaflet missing'); return; }
        map = L.map('map', {
          zoomControl: true, attributionControl: true,
          wheelPxPerZoomLevel: 80
        }).setView([0,0], 2);

        tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 24, maxNativeZoom: 19, attribution: '&copy; OpenStreetMap'
        }).addTo(map);
      }

      function makeRobotIcon(color='#ef4444', rotateDeg=0, muted=false){
        const svg = `<svg viewBox="0 0 24 24" width="24" height="24" fill="${color}" stroke="#0b0f18" stroke-width="1.2"><polygon points="12,2 22,22 12,17 2,22"/></svg>`;
        const div = document.createElement('div');
        div.className = 'robot-icon' + (muted ? ' muted' : '');
        div.innerHTML = svg;
        div.style.transform = `rotate(${rotateDeg}deg)`;
        return L.divIcon({ html: div, className:'', iconSize:[24,24], iconAnchor:[12,12] });
      }

      function overlayKey(m){
        const ns = m.ns || '/';
        return `${ns}|${m.map_name || ''}|${m.floor_name || ''}`;
      }

      function getOverlayGroup(key){
        let g = overlayGroups.get(key);
        if(!g){
          g = { img:null, verts: L.layerGroup().addTo(map), edges: L.layerGroup().addTo(map) };
          overlayGroups.set(key, g);
        }
        return g;
      }

      function clearOverlayGroup(g){
        if(g.img){ try{ map.removeLayer(g.img); }catch{} g.img = null; }
        try{ g.verts.clearLayers(); }catch{}
        try{ g.edges.clearLayers(); }catch{}
      }

      function applyOverlayAlpha(){
        for(const g of overlayGroups.values()){
          if(g.img && typeof g.img.setOpacity === 'function') g.img.setOpacity(overlayAlpha);
        }
      }

      function latlon(pt){ return [pt.lat, pt.lon]; }

      function styleVertexMarker(marker, isSelected){
        if(!marker) return;
        const S = sizes();
        marker.setStyle({
          color: isSelected ? '#064e3b' : '#0b0f18',
          weight: S.VERTEX_STROKE,
          fillColor: isSelected ? '#22c55e' : '#f59e0b',
          fillOpacity: 1
        });
        if (typeof marker.setRadius === 'function') {
          marker.setRadius(S.VERTEX_RADIUS);
        }
      }

      function updateSelectionUI(){
        document.getElementById('selList').textContent =
          'Selected: ' + (selectedOrder.length ? selectedOrder.join(' → ') : '-');
      }

      function setSelected(name, on){
        const m = nameToVertexMarker.get(name);
        if(on){
          if(!selected.has(name)){ selected.add(name); selectedOrder.push(name); }
          styleVertexMarker(m, true);
        }else{
          if(selected.has(name)){ selected.delete(name); selectedOrder = selectedOrder.filter(n => n !== name); }
          styleVertexMarker(m, false);
        }
        updateSelectionUI();
      }

      function clearSelection(){
        for(const n of Array.from(selected)) setSelected(n, false);
        updateSelectionUI();
      }

      // vertex popup
      function openMenu(latlng, payload){
        vmenuFor = payload;
        vmenuTitle.textContent = payload.name || 'Vertex';
        const pt = map.latLngToContainerPoint(latlng);
        vmenu.style.left = Math.round(pt.x + 10) + 'px';
        vmenu.style.top  = Math.round(pt.y - 10) + 'px';
        vmenu.style.display = 'block';
      }
      function closeMenu(){ vmenu.style.display='none'; vmenuFor = null; }
      document.addEventListener('pointerdown', (e)=>{ if(!vmenu.contains(e.target)) closeMenu(); });

      document.getElementById('actAddToPatrol').addEventListener('click', ()=>{
        if(!vmenuFor) return;
        setSelected(vmenuFor.name, true);
        closeMenu(); showToast(`Added ${vmenuFor.name}`);
      });
      document.getElementById('actRemoveFromPatrol').addEventListener('click', ()=>{
        if(!vmenuFor) return;
        setSelected(vmenuFor.name, false);
        closeMenu(); showToast(`Removed ${vmenuFor.name}`);
      });

      function updateRobots(list){
        const seen = new Set();
        for(const r of list){
          const key = r.ns || r.robot_name || '?';
          seen.add(key);
          const hasPos = Number.isFinite(r.lat) && Number.isFinite(r.lon);
          let m = markers.get(key);
          const pct = (typeof r.battery_pct==='number') ? Math.round(r.battery_pct*100) : '-';
          const label = `${r.robot_name || key} · ${r.ns} · ${r.mode_text || ''} · ${pct}% · ${r.map_name}/${r.floor_name}`;
          if(!hasPos){ if(m) m.setOpacity(0); continue; }
          const pt = [r.lat, r.lon];
          const icon = makeRobotIcon(r.has_fix ? '#22c55e' : '#ef4444', r.heading_deg || 0, !r.has_fix);
          if(!m){
            m = L.marker(pt, { icon });
            m.addTo(map);
            m.bindTooltip(label, { permanent:false, direction:'top', className:'robot-label' });
            markers.set(key, m);
          }else{
            m.setLatLng(pt);
            m.setIcon(icon);
            const tt = m.getTooltip(); if(tt) tt.setContent(label);
          }
          m.setOpacity(1);
        }
        for(const [k,m] of markers.entries()){
          if(!seen.has(k)) m.setOpacity(0);
        }
        document.getElementById('count').textContent = `${list.length} robot${list.length===1?'':'s'}`;
      }

      function updateMaps(data){
        lastMapsPayload = data;
        const infoParts = [];
        const seen = new Set();
        const overlayBounds = [];
        const vertexPts = [];
        const nsSet = new Set();
        const S = sizes();

        nameToVertexMarker.clear();

        for(const m of (data.maps || [])){
          const ns = m.ns || '/';
          nsSet.add(ns);
          const key = overlayKey(m);
          seen.add(key);
          infoParts.push(`${ns}:${m.map_name}/${m.floor_name}`);

          const g = getOverlayGroup(key);
          clearOverlayGroup(g);

          // edges (soft blue, scaled weight)
          if(Array.isArray(m.edges)){
            for(const e of m.edges){
              const pts = [latlon(e.a), latlon(e.b)];
              L.polyline(pts, { weight:S.EDGE_WEIGHT, opacity:0.45, color:'#78a6ff' }).addTo(g.edges);
              vertexPts.push(...pts);
            }
          }

          // vertices (orange dot + right label)
          if(Array.isArray(m.vertices)){
            for(const v of m.vertices){
              const ll = [v.lat, v.lon];
              const cm = L.circleMarker(ll, {
                radius: S.VERTEX_RADIUS,
                weight: S.VERTEX_STROKE,
                color:'#0b0f18',
                fillColor:'#f59e0b',
                fillOpacity:1
              });
              cm.bindTooltip(`${v.name}`, { permanent:true, direction:'right', offset:[10,-10], className:'v-label' });
              cm.on('click', (ev) => {
                if (ev.originalEvent && (ev.originalEvent.ctrlKey || ev.originalEvent.metaKey)) {
                  setSelected(v.name, !selected.has(v.name)); return;
                }
                openMenu(ev.latlng, { ns, name: v.name, lat: v.lat, lon: v.lon });
              });
              cm.addTo(g.verts);
              nameToVertexMarker.set(v.name, cm);
              if(selected.has(v.name)) styleVertexMarker(cm, true);
              vertexPts.push(ll);
            }
          }

          // image overlay
          if(m.overlay && m.image_url){
            const b = m.overlay.bounds;
            try{
              const bounds = L.latLngBounds([b[0][0], b[0][1]], [b[1][0], b[1][1]]);
              g.img = L.imageOverlay(m.image_url, bounds, { opacity: overlayAlpha, interactive:false }).addTo(map);
              overlayBounds.push(bounds);
            }catch(e){ warn('overlay bounds invalid for', key, e); }
          }
        }

        // remove groups that vanished
        for(const [k,g] of overlayGroups.entries()){
          if(!seen.has(k)){ clearOverlayGroup(g); overlayGroups.delete(k); }
        }

        // ns selector (first fill)
        const nsSel = document.getElementById('nsSelect');
        if(nsSel && nsSel.options.length === 0){
          [...nsSet].sort().forEach(ns=>{
            const opt=document.createElement('option'); opt.value=ns; opt.text=ns; nsSel.appendChild(opt);
          });
          if(nsSel.options.length){ activeNs = nsSel.value = nsSel.options[0].value; }
        }

        document.getElementById('mapsInfo').textContent = 'maps: ' + (infoParts.join(' | ') || '-');
        const countOverlays = [...overlayGroups.values()].filter(v => v.img).length;
        document.getElementById('overlayInfo').textContent = `overlay: ${countOverlays}`;

        if(firstMapCenter){
          if(!centerOnMaps(overlayBounds, vertexPts)) log('center: no overlay/vertex bounds yet');
          else firstMapCenter = false;
        }
      }

      function centerOnMaps(overlayBounds, vertexPts, pad=0.15){
        let union = null;
        if(overlayBounds && overlayBounds.length){
          for(const b of overlayBounds){ union = union ? union.extend(b) : L.latLngBounds(b.getSouthWest(), b.getNorthEast()); }
        }
        if(!union && vertexPts && vertexPts.length){
          for(const p of vertexPts){ const ll=L.latLng(p[0], p[1]); union = union ? union.extend(ll) : L.latLngBounds(ll, ll); }
        }
        if(union){ map.fitBounds(union.pad(pad)); return true; }
        return false;
      }

      async function fetchJSON(url){
        const r = await fetch(url, { cache:'no-store' });
        if(!r.ok) throw new Error(`${url} -> HTTP ${r.status}`);
        return r.json();
      }
      async function postJSON(url, body){
        const r = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body||{}) });
        const txt = await r.text(); let j={};
        try{ j = JSON.parse(txt || '{}'); }catch{ j = { raw: txt }; }
        if(!r.ok || j.ok === false) throw new Error(j.error || `HTTP ${r.status}`);
        return j;
      }

      async function fetchPathFor(ns){
        if(!ns) return;
        try{
          const j = await fetchJSON(`/api/${ns.replace(/^\//,'')}/path`);
          if(!j || j.ok === false) return;
          const prev = lastPathSeq.get(ns) || -1;
          if(j.seq === prev) return; // unchanged
          lastPathSeq.set(ns, j.seq);

          // draw/update path layer (thick green polyline)
          let layer = pathLayers.get(ns);
          const latlngs = (j.points || []).map(p => [p.lat, p.lon]);
          const S = sizes();
          if(!layer){
            layer = L.polyline(latlngs, { color:'#22c55e', weight:S.PATH_WEIGHT, opacity:0.95 });
            pathLayers.set(ns, layer);
            layer.addTo(map);
          }else{
            layer.setLatLngs(latlngs);
            layer.setStyle({ weight:S.PATH_WEIGHT });
          }
        }catch(e){ /* ignore */ }
      }

      // Apply scale to existing layers (edges, vertices, labels, path)
      function applyScaleToScene(){
        const S = sizes();
        // Update label font size via CSS var
        document.documentElement.style.setProperty('--v-label-font-size', `${S.LABEL_FONT_PX}px`);

        // Edges & vertices
        for(const g of overlayGroups.values()){
          try {
            for(const l of g.edges.getLayers()) l.setStyle({ weight: S.EDGE_WEIGHT });
          } catch {}
          try {
            for(const m of g.verts.getLayers()){
              if (typeof m.setRadius === 'function') m.setRadius(S.VERTEX_RADIUS);
              m.setStyle({ weight: S.VERTEX_STROKE });
            }
          } catch {}
        }

        // Paths
        for(const layer of pathLayers.values()){
          try { layer.setStyle({ weight: S.PATH_WEIGHT }); } catch {}
        }
      }

      async function tick(){
        let robotsOk=false, mapsOk=false, robotsJ=null, mapsJ=null;
        await Promise.all([
          (async()=>{ try{ robotsJ = await fetchJSON('/api/robots'); robotsOk = true; }catch(e){ warn('robots fetch failed', e); } })(),
          (async()=>{ try{ mapsJ   = await fetchJSON('/api/maps');   mapsOk   = true; }catch(e){ warn('maps fetch failed', e);   } })(),
        ]);

        if(robotsOk){ lastGoodRobots = robotsJ; updateRobots(robotsJ.robots || []); } else { updateRobots(lastGoodRobots.robots || []); }
        if(mapsOk){ lastGoodMaps = mapsJ; updateMaps(mapsJ); applyScaleToScene(); } else { updateMaps(lastGoodMaps); applyScaleToScene(); }

        // update path for active ns
        if(activeNs) fetchPathFor(activeNs);

        setStatus((robotsOk && mapsOk) ? ('ok ' + new Date().toLocaleTimeString()) : 'degraded');
      }

      window.addEventListener('load', ()=>{
        createMap();

        // overlay alpha
        document.getElementById('opacity').addEventListener('input', (e)=>{
          overlayAlpha = parseFloat(e.target.value || '0.5'); applyOverlayAlpha();
        });

        // sizing slider
        const sizeEl = document.getElementById('size');
        const sizeVal = document.getElementById('sizeVal');
        const updateSize = ()=>{
          SIZE_SCALE = parseFloat(sizeEl.value || '1.0');
          sizeVal.textContent = `x${SIZE_SCALE.toFixed(1)}`;
          applyScaleToScene();
        };
        sizeEl.addEventListener('input', updateSize);
        updateSize();

        document.getElementById('btnCenterMap').addEventListener('click', ()=>{
          const overlayBounds=[], vertexPts=[];
          for(const m of (lastGoodMaps.maps || [])){
            if(m.overlay && m.overlay.bounds){
              const b=m.overlay.bounds;
              try{ overlayBounds.push(L.latLngBounds([b[0][0], b[0][1]], [b[1][0], b[1][1]])); }catch{}
            }
            if(Array.isArray(m.vertices)){ for(const v of m.vertices) vertexPts.push([v.lat, v.lon]); }
            if(Array.isArray(m.edges)){ for(const e of m.edges){ vertexPts.push([e.a.lat,e.a.lon],[e.b.lat,e.b.lon]); } }
          }
          if(!centerOnMaps(overlayBounds, vertexPts)) warn('center: nothing to fit');
        });

        document.getElementById('nsSelect').addEventListener('change', (e)=>{ activeNs = e.target.value || '/'; });

        document.getElementById('btnPublishPatrol').addEventListener('click', async ()=>{
          if(!activeNs) return alert('Select namespace');
          if(!selectedOrder.length) return alert('Select at least one vertex');
          try{
            await postJSON(`/api/${activeNs.replace(/^\//,'')}/patrol`, { sequence: selectedOrder, loops: 1 });
            showToast('Patrol scheduled');
          }catch(e){ alert('Patrol failed: ' + e.message); }
        });

        document.getElementById('btnClearSel').addEventListener('click', clearSelection);

        document.getElementById('btnCancelAll').addEventListener('click', async ()=>{
          if(!activeNs) return alert('Select namespace');
          try{ await postJSON(`/api/${activeNs.replace(/^\//,'')}/cancel_all`, {}); showToast('CancelAll sent'); }
          catch(e){ alert('CancelAll failed: ' + e.message); }
        });

        document.getElementById('btnReturnHome').addEventListener('click', async ()=>{
          if(!activeNs) return alert('Select namespace');
          try{ await postJSON(`/api/${activeNs.replace(/^\//,'')}/return_home`, {}); showToast('Return home sent'); }
          catch(e){ alert('Return home failed: ' + e.message); }
        });

        setInterval(tick, 1000);
      });
    </script>
  </body>
</html>
