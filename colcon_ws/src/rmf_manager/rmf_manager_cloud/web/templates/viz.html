<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>RMF â€” Multi-Robot Global View</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous" defer></script>

    <style>
      :root {
        color-scheme: dark;
        /* dynamic sizing controlled by JS */
        --v-label-font-size: 15px; /* vertex label size (scaled by slider) */
        --v-label-pad-v: 4px;
        --v-label-pad-h: 8px;
      }

      html, body { height:100%; margin:0; }
      body { background:#0f1115; color:#e6edf3; font:14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }

      /* Top bar */
      #top {
        display:flex; gap:12px; align-items:center; padding:8px 12px;
        background:#161a22; border-bottom:1px solid #232a36; position:sticky; top:0; z-index:10;
      }
      .pill { padding:4px 8px; background:#222a36; border:1px solid #2f3744; border-radius:999px; white-space:nowrap; }
      .legend { display:flex; gap:10px; align-items:center; }
      .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
      .ok { background:#22c55e; } .stale { background:#a3a3a3; } .no { background:#ef4444; }

      /* Map */
      #map { width:100%; height: calc(100% - 72px); }

      /* Robot tooltip */
      .robot-label {
        background: rgba(17,22,31,.9); color:#e6edf3; border:1px solid #2a3240; padding:2px 6px; border-radius:6px; font-weight:600;
      }
      .leaflet-tooltip.robot-label { box-shadow:none; }

      /* Vertex label (grows with --v-label-font-size) */
      .leaflet-tooltip.v-label {
        background: rgba(0,0,0,.58);
        color:#f8fafc; border:1px solid #2a3240; border-radius:6px;
        font-weight:700;
        padding: var(--v-label-pad-v) var(--v-label-pad-h);
        font-size: var(--v-label-font-size);
      }

      /* Bottom bar */
      #bar {
        position:fixed; left:8px; bottom:8px; z-index:9999; display:flex; gap:8px; align-items:center; flex-wrap:wrap;
        background:#11161f; border:1px solid #2a3240; padding:6px 8px; border-radius:8px; font-size:12px;
      }
      #opacity, #size { width:120px; }
      button, select, input[type="range"], input[type="number"] {
        padding:6px 10px; border-radius:8px; background:#263143; color:#e6edf3; border:1px solid #39465a; cursor:pointer;
      }
      button:hover { filter:brightness(1.1); }
      .badge { padding:2px 6px; background:#22314a; border:1px solid #2d3b52; border-radius:8px; }

      /* Popup menu for vertex (patrol only) */
      .menu {
        position:absolute; z-index:99999; min-width:180px; background:#11161f; color:#e6edf3;
        border:1px solid #2a3240; border-radius:10px; box-shadow:0 12px 30px rgba(0,0,0,.45);
        padding:8px; display:none;
      }
      .menu .row { display:flex; gap:8px; flex-wrap:wrap; }
      .menu button { flex:1; }

      /* Toast */
      #toast {
        position: fixed; left: 50%; transform: translateX(-50%);
        bottom: 18px; background:#1b2130; color:#e6edf3; border:1px solid #2a3240;
        padding:10px 14px; border-radius:10px; display:none; z-index:99999;
      }

      /* Mini robot dashboard (right center) */
      #miniDash {
        position: fixed;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        z-index: 9999;
        min-width: 190px;
        max-width: 260px;
        background: #11161f;
        border: 1px solid #2a3240;
        border-radius: 10px;
        padding: 10px 12px;
        box-shadow: 0 14px 35px rgba(0,0,0,.45);
        font-size: 13px;
      }
      #miniDash .mini-title {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 6px;
        font-weight: 600;
      }
      #miniDash .mini-pill {
        padding: 2px 6px;
        border-radius: 999px;
        border: 1px solid #2a3240;
        background: #22314a;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.03em;
      }
      #miniDash .mini-row {
        display: flex;
        justify-content: space-between;
        margin-top: 4px;
      }
      #miniDash .mini-label {
        color: #9ca3af;
      }
      #miniDash .mini-value {
        font-variant-numeric: tabular-nums;
      }

      /* ---- Camera dock (top-right) ---- */
      #camDock {
        position: fixed;
        right: 12px;
        top: 60px;
        z-index: 9998;
        width: 320px;
        max-height: 60%;
        background: #11161f;
        border: 1px solid #2a3240;
        border-radius: 10px;
        padding: 8px 10px;
        box-shadow: 0 10px 30px rgba(0,0,0,.5);
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      #camDock .cam-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 12px;
        color: #9ca3af;
      }
      #camButtons {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
      }
      .cam-btn {
        font-size: 11px;
        padding: 4px 6px;
        border-radius: 999px;
        border: 1px solid #2a3240;
        background: #1b2434;
        cursor: pointer;
      }
      .cam-btn.active {
        border-color: #22c55e;
        color: #22c55e;
      }
      #camSlots {
        display: flex;
        gap: 6px;
      }
      .cam-slot {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .cam-slot-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 11px;
        color: #9ca3af;
      }
      .cam-slot-title {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .cam-slot-close {
        background: transparent;
        border: none;
        color: #9ca3af;
        cursor: pointer;
        padding: 0 4px;
        font-size: 14px;
        line-height: 1;
      }
      .cam-slot-body {
        position: relative;
        background: #050816;
        border-radius: 6px;
        overflow: hidden;

        /* fixed 16:9 tile, independent of iframe internals */
        padding-top: 56.25%;  /* 9 / 16 * 100% */
      }

      .cam-frame {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border: none;
        cursor: pointer;

        /* make sure the embedded page fully covers the tile */
        min-width: 100%;
        min-height: 100%;
        box-sizing: border-box;
      }

      /* Fullscreen camera overlay */
      #camFullscreen {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      }
      #camFullscreen.active {
        display: flex;
      }
      .cam-full-inner {
        position: relative;
        width: 90%;
        max-width: 960px;
        aspect-ratio: 16 / 9;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 16px 40px rgba(0,0,0,.7);
        background: #050816;
      }
      #camFullFrame {
        width: 100%;
        height: 100%;
        border: none;
      }
      #camFullClose {
        position: absolute;
        top: 8px;
        right: 10px;
        z-index: 2;
        background: rgba(15,23,42,.7);
        border: none;
        color: #e5e7eb;
        border-radius: 999px;
        width: 28px;
        height: 28px;
        cursor: pointer;
        font-size: 18px;
        line-height: 1;
      }
      #camFullLabel {
        position: absolute;
        left: 10px;
        bottom: 8px;
        padding: 4px 8px;
        background: rgba(15,23,42,.75);
        border-radius: 999px;
        font-size: 12px;
        color: #e5e7eb;
      }

      @media (max-width: 900px) {
        #camDock {
          top: 52px;
          width: 320px;
          max-height: 50%;
        }
        #miniDash {
          display: none;
        }
      }

    </style>
  </head>
  <body>
    <div id="top">
      <span class="pill" id="status">loadingâ€¦</span>
      <span class="pill">zoom: wheel â€¢ pan: drag</span>
      <span class="legend"><span class="dot ok"></span> fix <span class="dot stale"></span> stale <span class="dot no"></span> no fix</span>
      <span class="pill" id="count">0 robots</span>
      <span class="pill" id="mapsInfo">maps: -</span>
      <span class="pill" id="overlayInfo">overlay: -</span>
      <span class="pill" id="selList">Selected: -</span>
    </div>


    <div id="map" aria-label="OpenStreetMap with robots and overlays"></div>

    <!-- Mini dashboard: right-center status for currently selected namespace -->
    <div id="miniDash" aria-label="Robot status mini dashboard">
      <div class="mini-title">
        <span id="miniRobotName">â€”</span>
        <span id="miniModePill" class="mini-pill">
          <span id="miniMode">â€”</span>
        </span>
      </div>
      <div class="mini-row">
        <span class="mini-label">Speed</span>
        <span class="mini-value"><span id="miniSpeed">â€”</span> m/s</span>
      </div>
      <div class="mini-row">
        <span class="mini-label">Battery</span>
        <span class="mini-value">
          <span id="miniBattPct">â€”</span>% Â·
          <span id="miniBattVolt">â€”</span> V
        </span>
      </div>
    </div>

    <!-- Camera dock: 2 tiles + camera buttons for current namespace -->
    <div id="camDock" aria-label="Robot cameras">
      <div class="cam-header">
        <span>Cameras for <span id="camNsLabel">â€”</span></span>
        <span id="camHint" style="font-size:11px;">click button â†’ tile, click tile â†’ zoom</span>
      </div>
      <div id="camButtons"></div>
      <div id="camSlots">
        <div class="cam-slot" data-slot="0">
          <div class="cam-slot-header">
            <span class="cam-slot-title" data-slot-title="0">Empty</span>
            <button class="cam-slot-close" data-slot-close="0" type="button">Ã—</button>
          </div>
          <div class="cam-slot-body">
            <iframe class="cam-frame" data-slot-frame="0" title="Camera 1" allowfullscreen></iframe>
          </div>
        </div>
        <div class="cam-slot" data-slot="1">
          <div class="cam-slot-header">
            <span class="cam-slot-title" data-slot-title="1">Empty</span>
            <button class="cam-slot-close" data-slot-close="1" type="button">Ã—</button>
          </div>
          <div class="cam-slot-body">
            <iframe class="cam-frame" data-slot-frame="1" title="Camera 2" allowfullscreen></iframe>
          </div>
        </div>
      </div>
    </div>

    <!-- Fullscreen camera overlay -->
    <div id="camFullscreen" aria-label="Fullscreen camera">
      <div class="cam-full-inner">
        <button id="camFullClose" type="button">Ã—</button>
        <iframe id="camFullFrame" title="Fullscreen camera" allowfullscreen scrolling="no"></iframe>
        <div id="camFullLabel"></div>
      </div>
    </div>

    <div id="bar">
      <label>ns <select id="nsSelect"></select></label>
      <label>
        loops
        <input id="loopsInput" type="number" min="1" max="99" step="1" value="1" style="width:3.2rem; margin-left:4px;" />
      </label>

      <button id="btnPublishPatrol" type="button">Publish patrol</button>
      <button id="btnClearSel" type="button">Clear</button>
      <button id="btnCancelAll" type="button">Cancel all</button>
      <button id="btnReturnHome" type="button">Return home</button>

      <span class="badge">overlay Î±</span>
      <input id="opacity" type="range" min="0" max="1" step="0.05" value="0.5"/>

      <span class="badge">size</span>
      <input id="size" type="range" min="0.6" max="2.5" step="0.1" value="1.4"/>
      <span id="sizeVal" class="pill">x1.4</span>

      <button id="btnCenterMap" type="button">Center</button>
    </div>

    <div id="toast"></div>

    <!-- Patrol-only vertex menu -->
    <div id="vmenu" class="menu" role="dialog" aria-modal="false">
      <div class="title" id="vmenuTitle" style="font-weight:700; margin-bottom:6px;">Vertex</div>
      <div class="row">
        <button id="actAddToPatrol">Add to patrol</button>
        <button id="actRemoveFromPatrol">Remove from patrol</button>
      </div>
    </div>

    <script>
      const DEBUG = true;
      function log(...a){ if(DEBUG) console.log('[UI]', ...a); }
      function warn(...a){ if(DEBUG) console.warn('[UI]', ...a); }
      function err(...a){ console.error('[UI]', ...a); }
      function setStatus(s){ const el=document.getElementById('status'); if(el) el.textContent=s; }
      function showToast(msg, ms=1600){ const t=document.getElementById('toast'); t.textContent=msg; t.style.display='block'; clearTimeout(showToast._t); showToast._t=setTimeout(()=>t.style.display='none', ms); }

      // ----- Sizing config (scaled at runtime) -----
      const BASE = Object.freeze({
        VERTEX_RADIUS: 6.5,       // bigger default vertex dot
        VERTEX_STROKE: 2,         // vertex outline thickness
        EDGE_WEIGHT:   3,         // graph edge thickness
        PATH_WEIGHT:   6,         // robot planned path thickness
        LABEL_FONT_PX: 15         // vertex label font size
      });
      let SIZE_SCALE = 1.4;       // default UI slider value

      function sizes(){
        return {
          VERTEX_RADIUS: Math.max(2, Math.round(BASE.VERTEX_RADIUS * SIZE_SCALE)),
          VERTEX_STROKE: Math.max(1, Math.round(BASE.VERTEX_STROKE * SIZE_SCALE)),
          EDGE_WEIGHT:   Math.max(1, Math.round(BASE.EDGE_WEIGHT * SIZE_SCALE)),
          PATH_WEIGHT:   Math.max(2, Math.round(BASE.PATH_WEIGHT * SIZE_SCALE)),
          LABEL_FONT_PX: Math.max(10, Math.round(BASE.LABEL_FONT_PX * SIZE_SCALE))
        };
      }

      let map, tiles;

      // robots
      const markers = new Map();

      // cameras (go2rtc): ns -> [{id, stream, label}]
      let allCameras = {};
      let go2rtcBase = "";
      // two visible slots: index 0 and 1
      let activeCamSlots = [null, null]; // each: {ns, stream, label}
      // snapshot of last camera config to avoid unnecessary reloads
      let lastCamerasSnapshot = null;

      async function loadCameras(){
        try{
          const j = await fetchJSON('/api/cameras');
          if(j && j.ok !== false){
            // only update UI when config/base_url actually changes
            const snapshot = JSON.stringify([j.cameras || {}, j.base_url || ""]);
            if (snapshot === lastCamerasSnapshot) {
              return; // nothing changed, keep iframes running
            }
            lastCamerasSnapshot = snapshot;

            allCameras = j.cameras || {};
            go2rtcBase = j.base_url || "";
            log('cameras loaded', allCameras);
            refreshCameraUI();
          }
        }catch(e){
          warn('loadCameras failed', e);
        }
      }

      function go2rtcUrlForStream(streamName){
        let base = go2rtcBase;
        if(!base){
          // default: same host, port 1984
          base = window.location.protocol + '//' + window.location.hostname + ':1984';
        }
        if(base.endsWith('/')) base = base.slice(0, -1);
        return `${base}/stream.html?src=${encodeURIComponent(streamName)}`;
      }

      function refreshCameraUI(){
        const dock = document.getElementById('camDock');
        if(!dock) return;

        // Decide which namespace to show cameras for:
        // 1) prefer activeNs
        // 2) if it has no cameras, fall back to the first ns that *does* have cameras
        const nsKeys = Object.keys(allCameras || {});
        let ns = activeNs || '/';
        if (!allCameras[ns] && nsKeys.length) {
          // if "/" exists in camera map, prefer it, otherwise pick first key
          ns = nsKeys.includes('/') ? '/' : nsKeys[0];
          activeNs = ns;

          // keep <select> in sync if present
          const nsSel = document.getElementById('nsSelect');
          if (nsSel && nsSel.value !== ns) {
            nsSel.value = ns;
          }
        }

        const labelEl = document.getElementById('camNsLabel');
        if(labelEl) labelEl.textContent = ns;

        const cams = allCameras[ns] || [];

        const btnWrap = document.getElementById('camButtons');
        if(btnWrap){
          btnWrap.innerHTML = '';
          if(!cams.length){
            const span = document.createElement('span');
            span.style.fontSize = '11px';
            span.style.color = '#6b7280';
            span.textContent = 'No cameras configured';
            btnWrap.appendChild(span);
          }else{
            cams.forEach((c, idx)=>{
              const b = document.createElement('button');
              b.type = 'button';
              b.className = 'cam-btn';
              b.textContent = c.label || c.id || (`cam${idx+1}`);
              b.addEventListener('click', ()=>{
                assignCameraToSlot(c);
              });
              btnWrap.appendChild(b);
            });
          }
        }

        // If we switched ns, clear slots that belong to other ns
        activeCamSlots.forEach((slot, i)=>{
          if(slot && slot.ns !== ns){
            activeCamSlots[i] = null;
          }
        });

        // Auto-fill: first time for this ns â†’ put first 2 cams into slots
        if(cams.length && !activeCamSlots[0] && !activeCamSlots[1]){
          activeCamSlots[0] = {
            ns,
            stream: cams[0].stream,
            label: cams[0].label || cams[0].id || cams[0].stream,
          };
          if(cams.length > 1){
            activeCamSlots[1] = {
              ns,
              stream: cams[1].stream,
              label: cams[1].label || cams[1].id || cams[1].stream,
            };
          }
        }

        applySlotsToDom();
      }

      function assignCameraToSlot(cam){
        const ns = activeNs || '/';
        // pick slot: first empty, otherwise flip slot 0
        let slotIdx = activeCamSlots.findIndex(s => s === null);
        if(slotIdx === -1){
          slotIdx = 0;
        }
        activeCamSlots[slotIdx] = {
          ns,
          stream: cam.stream,
          label: cam.label || cam.id || cam.stream,
        };
        applySlotsToDom();
      }

      function clearSlot(idx){
        activeCamSlots[idx] = null;
        applySlotsToDom();
      }

      function applySlotsToDom(){
        for(let i=0; i<2; i++){
          const s = activeCamSlots[i];
          const frame = document.querySelector(`iframe[data-slot-frame="${i}"]`);
          const title = document.querySelector(`span[data-slot-title="${i}"]`);
          const closeBtn = document.querySelector(`button[data-slot-close="${i}"]`);
          if(!frame || !title || !closeBtn) continue;

          frame.setAttribute('scrolling', 'no');
          frame.style.overflow = 'hidden';

          if(!s){
            const blank = 'about:blank';
            if (frame.dataset.currentSrc !== blank) {
              frame.src = blank;
              frame.dataset.currentSrc = blank;
            }
            title.textContent = 'Empty';
            closeBtn.style.visibility = 'hidden';
          }else{
            const newUrl = go2rtcUrlForStream(s.stream);
            if (frame.dataset.currentSrc !== newUrl) {
              // only reload iframe if stream actually changed
              frame.src = newUrl;
              frame.dataset.currentSrc = newUrl;
            }
            title.textContent = s.label;
            closeBtn.style.visibility = 'visible';
          }
        }
      }

      function setupCameraDomInteractions(){
        // slot close buttons
        for(let i=0; i<2; i++){
          const closeBtn = document.querySelector(`button[data-slot-close="${i}"]`);
          if(closeBtn){
            closeBtn.addEventListener('click', (ev)=>{
              ev.stopPropagation();
              clearSlot(i);
            });
          }
          const frame = document.querySelector(`iframe[data-slot-frame="${i}"]`);
          if(frame){
            frame.addEventListener('click', ()=>{
              const s = activeCamSlots[i];
              if(!s) return;
              openFullscreenCamera(s);
            });
          }
        }

        const full = document.getElementById('camFullscreen');
        const fullClose = document.getElementById('camFullClose');
        if(fullClose){
          fullClose.addEventListener('click', ()=>{
            full.classList.remove('active');
          });
        }
        if(full){
          // click on dark area closes
          full.addEventListener('click', (ev)=>{
            if(ev.target === full){
              full.classList.remove('active');
            }
          });
        }
      }

      function openFullscreenCamera(slot){
        const full = document.getElementById('camFullscreen');
        const frame = document.getElementById('camFullFrame');
        const label = document.getElementById('camFullLabel');
        if(!full || !frame || !label) return;

        frame.src = go2rtcUrlForStream(slot.stream);
        label.textContent = `${slot.ns} Â· ${slot.label}`;
        full.classList.add('active');
      }

      // overlays per (ns|map|floor)
      const overlayGroups = new Map(); // key -> {img, verts, edges}
      let overlayAlpha = 0.5;

      // degraded caches
      let lastGoodRobots = { robots: [], t: 0 };
      let lastGoodMaps   = { maps: [],   t: 0 };

      let firstMapCenter = true;
      let lastMapsPayload = null;

      // ns + patrol selection
      let activeNs = '/';
      const selected = new Set();
      let selectedOrder = [];
      const nameToVertexMarker = new Map();

      // path cache
      const pathLayers = new Map(); // ns -> L.Polyline
      const lastPathSeq = new Map();

      // vertex popup state
      const vmenu = document.getElementById('vmenu');
      const vmenuTitle = document.getElementById('vmenuTitle');
      let vmenuFor = null; // {ns, name, lat, lon}

      function createMap(){
        if(!window.L){ err('Leaflet missing'); return; }
        map = L.map('map', {
          zoomControl: true, attributionControl: true,
          wheelPxPerZoomLevel: 80
        }).setView([0,0], 2);

        tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 24, maxNativeZoom: 19, attribution: '&copy; OpenStreetMap'
        }).addTo(map);
      }

      function makeRobotIcon(color='#ef4444', rotateDeg=0, muted=false){
        const svg = `<svg viewBox="0 0 24 24" width="24" height="24" fill="${color}" stroke="#0b0f18" stroke-width="1.2"><polygon points="12,2 22,22 12,17 2,22"/></svg>`;
        const div = document.createElement('div');
        div.className = 'robot-icon' + (muted ? ' muted' : '');
        div.innerHTML = svg;
        div.style.transform = `rotate(${rotateDeg}deg)`;
        return L.divIcon({ html: div, className:'', iconSize:[24,24], iconAnchor:[12,12] });
      }

      function overlayKey(m){
        const ns = m.ns || '/';
        return `${ns}|${m.map_name || ''}|${m.floor_name || ''}`;
      }

      function getOverlayGroup(key){
        let g = overlayGroups.get(key);
        if(!g){
          g = { img:null, verts: L.layerGroup().addTo(map), edges: L.layerGroup().addTo(map) };
          overlayGroups.set(key, g);
        }
        return g;
      }

      function clearOverlayGroup(g){
        if(g.img){ try{ map.removeLayer(g.img); }catch{} g.img = null; }
        try{ g.verts.clearLayers(); }catch{}
        try{ g.edges.clearLayers(); }catch{}
      }

      function applyOverlayAlpha(){
        for(const g of overlayGroups.values()){
          if(g.img && typeof g.img.setOpacity === 'function') g.img.setOpacity(overlayAlpha);
        }
      }

      function latlon(pt){ return [pt.lat, pt.lon]; }

      function styleVertexMarker(marker, isSelected){
        if(!marker) return;
        const S = sizes();
        marker.setStyle({
          color: isSelected ? '#064e3b' : '#0b0f18',
          weight: S.VERTEX_STROKE,
          fillColor: isSelected ? '#22c55e' : '#f59e0b',
          fillOpacity: 1
        });
        if (typeof marker.setRadius === 'function') {
          marker.setRadius(S.VERTEX_RADIUS);
        }
      }

      function updateSelectionUI(){
        document.getElementById('selList').textContent =
          'Selected: ' + (selectedOrder.length ? selectedOrder.join(' â†’ ') : '-');
      }

      function setSelected(name, on){
        const m = nameToVertexMarker.get(name);
        if(on){
          if(!selected.has(name)){ selected.add(name); selectedOrder.push(name); }
          styleVertexMarker(m, true);
        }else{
          if(selected.has(name)){ selected.delete(name); selectedOrder = selectedOrder.filter(n => n !== name); }
          styleVertexMarker(m, false);
        }
        updateSelectionUI();
      }

      function clearSelection(){
        for(const n of Array.from(selected)) setSelected(n, false);
        updateSelectionUI();
      }

      // vertex popup
      function openMenu(latlng, payload){
        vmenuFor = payload;
        vmenuTitle.textContent = payload.name || 'Vertex';
        const pt = map.latLngToContainerPoint(latlng);
        vmenu.style.left = Math.round(pt.x + 10) + 'px';
        vmenu.style.top  = Math.round(pt.y - 10) + 'px';
        vmenu.style.display = 'block';
      }
      function closeMenu(){ vmenu.style.display='none'; vmenuFor = null; }
      document.addEventListener('pointerdown', (e)=>{ if(!vmenu.contains(e.target)) closeMenu(); });

      document.getElementById('actAddToPatrol').addEventListener('click', ()=>{
        if(!vmenuFor) return;
        setSelected(vmenuFor.name, true);
        closeMenu(); showToast(`Added ${vmenuFor.name}`);
      });
      document.getElementById('actRemoveFromPatrol').addEventListener('click', ()=>{
        if(!vmenuFor) return;
        setSelected(vmenuFor.name, false);
        closeMenu(); showToast(`Removed ${vmenuFor.name}`);
      });

      function updateMiniDashboard(list){
        const panel = document.getElementById('miniDash');
        if (!panel) return;

        const ns = activeNs || '/';
        let r = null;
        if (Array.isArray(list) && list.length) {
          r = list.find(o => (o.ns || '/') === ns) || list[0];
        }

        const nameEl = document.getElementById('miniRobotName');
        const modeEl = document.getElementById('miniMode');
        const speedEl = document.getElementById('miniSpeed');
        const pctEl = document.getElementById('miniBattPct');
        const voltEl = document.getElementById('miniBattVolt');
        const modePill = document.getElementById('miniModePill');

        if (!r) {
          panel.style.opacity = 0.4;
          if (nameEl) nameEl.textContent = 'â€”';
          if (modeEl) modeEl.textContent = 'â€”';
          if (speedEl) speedEl.textContent = 'â€”';
          if (pctEl) pctEl.textContent = 'â€”';
          if (voltEl) voltEl.textContent = 'â€”';
          if (modePill) {
            modePill.style.borderColor = '#2a3240';
            modePill.style.color = '#e6edf3';
          }
          return;
        }

        panel.style.opacity = 1;

        const pctRaw    = (typeof r.battery_pct === 'number')   ? r.battery_pct   : NaN;
        const pct       = Number.isFinite(pctRaw)               ? Math.round(pctRaw * 100) : null;
        const vSpeedRaw = (typeof r.vehicle_speed === 'number') ? r.vehicle_speed : NaN;
        const vSpeed    = Number.isFinite(vSpeedRaw)            ? vSpeedRaw : null;
        const vBattRaw  = (typeof r.battery_voltage === 'number') ? r.battery_voltage : NaN;
        const vBatt     = Number.isFinite(vBattRaw)             ? vBattRaw : null;

        if (nameEl) nameEl.textContent = r.robot_name || r.ns || 'robot';
        if (modeEl) modeEl.textContent = r.mode_text || (typeof r.mode === 'number' ? `mode ${r.mode}` : 'â€”');
        if (speedEl) speedEl.textContent = (vSpeed !== null) ? vSpeed.toFixed(2) : 'â€”';
        if (pctEl) pctEl.textContent = (pct !== null) ? String(pct) : 'â€”';
        if (voltEl) voltEl.textContent = (vBatt !== null) ? vBatt.toFixed(1) : 'â€”';

        // Simple color hint by mode_text
        if (modePill) {
          const modeTxt = (r.mode_text || '').toLowerCase();
          let color = '#22c55e';  // default: "ok"/moving

          if (modeTxt.includes('idle')) {
            color = '#9ca3af';
          } else if (modeTxt.includes('error') || modeTxt.includes('fault') || modeTxt.includes('alarm')) {
            color = '#ef4444';
          }

          modePill.style.borderColor = color;
          modePill.style.color = color;
        }
      }


      function updateRobots(list){
        const seen = new Set();
        for(const r of list){
          const key = r.ns || r.robot_name || '?';
          seen.add(key);
          const hasPos = Number.isFinite(r.lat) && Number.isFinite(r.lon);
          let m = markers.get(key);
          const pct = (typeof r.battery_pct==='number') ? Math.round(r.battery_pct*100) : '-';
          const label = `${r.robot_name || key} Â· ${r.ns} Â· ${r.mode_text || ''} Â· ${pct}% Â· ${r.map_name}/${r.floor_name}`;
          if(!hasPos){ if(m) m.setOpacity(0); continue; }
          const pt = [r.lat, r.lon];
          const icon = makeRobotIcon(r.has_fix ? '#ef4444' : '#000000', r.heading_deg || 0, !r.has_fix);
          if(!m){
            m = L.marker(pt, { icon });
            m.addTo(map);
            m.bindTooltip(label, { permanent:false, direction:'top', className:'robot-label' });
            markers.set(key, m);
          }else{
            m.setLatLng(pt);
            m.setIcon(icon);
            const tt = m.getTooltip(); if(tt) tt.setContent(label);
          }
          m.setOpacity(1);
        }
        for(const [k,m] of markers.entries()){
          if(!seen.has(k)) m.setOpacity(0);
        }
        document.getElementById('count').textContent = `${list.length} robot${list.length===1?'':'s'}`;
        updateMiniDashboard(list);
      }

      function updateMaps(data){
        lastMapsPayload = data;
        const infoParts = [];
        const seen = new Set();
        const overlayBounds = [];
        const vertexPts = [];
        const nsSet = new Set();
        const S = sizes();

        nameToVertexMarker.clear();

        for(const m of (data.maps || [])){
          const ns = m.ns || '/';
          nsSet.add(ns);
          const key = overlayKey(m);
          seen.add(key);
          infoParts.push(`${ns}:${m.map_name}/${m.floor_name}`);

          const g = getOverlayGroup(key);
          clearOverlayGroup(g);

          // edges (soft blue, scaled weight)
          if(Array.isArray(m.edges)){
            for(const e of m.edges){
              const pts = [latlon(e.a), latlon(e.b)];
              L.polyline(pts, { weight:S.EDGE_WEIGHT, opacity:0.45, color:'#78a6ff' }).addTo(g.edges);
              vertexPts.push(...pts);
            }
          }

          // vertices (orange dot + right label)
          if(Array.isArray(m.vertices)){
            for(const v of m.vertices){
              const ll = [v.lat, v.lon];
              const cm = L.circleMarker(ll, {
                radius: S.VERTEX_RADIUS,
                weight: S.VERTEX_STROKE,
                color:'#0b0f18',
                fillColor:'#f59e0b',
                fillOpacity:1
              });
              cm.bindTooltip(`${v.name}`, { permanent:true, direction:'right', offset:[10,-10], className:'v-label' });
              cm.on('click', (ev) => {
                if (ev.originalEvent && (ev.originalEvent.ctrlKey || ev.originalEvent.metaKey)) {
                  setSelected(v.name, !selected.has(v.name)); return;
                }
                openMenu(ev.latlng, { ns, name: v.name, lat: v.lat, lon: v.lon });
              });
              cm.addTo(g.verts);
              nameToVertexMarker.set(v.name, cm);
              if(selected.has(v.name)) styleVertexMarker(cm, true);
              vertexPts.push(ll);
            }
          }

          // image overlay
          if(m.overlay && m.image_url){
            const b = m.overlay.bounds;
            try{
              const bounds = L.latLngBounds([b[0][0], b[0][1]], [b[1][0], b[1][1]]);
              g.img = L.imageOverlay(m.image_url, bounds, { opacity: overlayAlpha, interactive:false }).addTo(map);
              overlayBounds.push(bounds);
            }catch(e){ warn('overlay bounds invalid for', key, e); }
          }
        }

        // remove groups that vanished
        for(const [k,g] of overlayGroups.entries()){
          if(!seen.has(k)){ clearOverlayGroup(g); overlayGroups.delete(k); }
        }

        // ns selector (first fill)
        const nsSel = document.getElementById('nsSelect');
        if(nsSel && nsSel.options.length === 0){
          [...nsSet].sort().forEach(ns=>{
            const opt=document.createElement('option'); opt.value=ns; opt.text=ns; nsSel.appendChild(opt);
          });
          if(nsSel.options.length){ activeNs = nsSel.value = nsSel.options[0].value; }
        }

        document.getElementById('mapsInfo').textContent = 'maps: ' + (infoParts.join(' | ') || '-');
        const countOverlays = [...overlayGroups.values()].filter(v => v.img).length;
        document.getElementById('overlayInfo').textContent = `overlay: ${countOverlays}`;

        if(firstMapCenter){
          if(!centerOnMaps(overlayBounds, vertexPts)) log('center: no overlay/vertex bounds yet');
          else firstMapCenter = false;
        }
      }

      function centerOnMaps(overlayBounds, vertexPts, pad=0.15){
        let union = null;
        if(overlayBounds && overlayBounds.length){
          for(const b of overlayBounds){ union = union ? union.extend(b) : L.latLngBounds(b.getSouthWest(), b.getNorthEast()); }
        }
        if(!union && vertexPts && vertexPts.length){
          for(const p of vertexPts){ const ll=L.latLng(p[0], p[1]); union = union ? union.extend(ll) : L.latLngBounds(ll, ll); }
        }
        if(union){ map.fitBounds(union.pad(pad)); return true; }
        return false;
      }

      async function fetchJSON(url){
        const r = await fetch(url, { cache:'no-store' });
        if(!r.ok) throw new Error(`${url} -> HTTP ${r.status}`);
        return r.json();
      }
      async function postJSON(url, body){
        const r = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body||{}) });
        const txt = await r.text(); let j={};
        try{ j = JSON.parse(txt || '{}'); }catch{ j = { raw: txt }; }
        if(!r.ok || j.ok === false) throw new Error(j.error || `HTTP ${r.status}`);
        return j;
      }

      async function fetchPathFor(ns){
        if(!ns) return;
        try{
          const j = await fetchJSON(`/api/${ns.replace(/^\//,'')}/path`);
          if(!j || j.ok === false) return;
          const prev = lastPathSeq.get(ns) || -1;
          if(j.seq === prev) return; // unchanged
          lastPathSeq.set(ns, j.seq);

          // draw/update path layer (thick green polyline)
          let layer = pathLayers.get(ns);
          const latlngs = (j.points || []).map(p => [p.lat, p.lon]);
          const S = sizes();
          if(!layer){
            layer = L.polyline(latlngs, { color:'#22c55e', weight:S.PATH_WEIGHT, opacity:0.95 });
            pathLayers.set(ns, layer);
            layer.addTo(map);
          }else{
            layer.setLatLngs(latlngs);
            layer.setStyle({ weight:S.PATH_WEIGHT });
          }
        }catch(e){ /* ignore */ }
      }

      // Apply scale to existing layers (edges, vertices, labels, path)
      function applyScaleToScene(){
        const S = sizes();
        // Update label font size via CSS var
        document.documentElement.style.setProperty('--v-label-font-size', `${S.LABEL_FONT_PX}px`);

        // Edges & vertices
        for(const g of overlayGroups.values()){
          try {
            for(const l of g.edges.getLayers()) l.setStyle({ weight: S.EDGE_WEIGHT });
          } catch {}
          try {
            for(const m of g.verts.getLayers()){
              if (typeof m.setRadius === 'function') m.setRadius(S.VERTEX_RADIUS);
              m.setStyle({ weight: S.VERTEX_STROKE });
            }
          } catch {}
        }

        // Paths
        for(const layer of pathLayers.values()){
          try { layer.setStyle({ weight: S.PATH_WEIGHT }); } catch {}
        }
      }

      async function tick(){
        let robotsOk=false, mapsOk=false, robotsJ=null, mapsJ=null;
        await Promise.all([
          (async()=>{ try{ robotsJ = await fetchJSON('/api/robots'); robotsOk = true; }catch(e){ warn('robots fetch failed', e); } })(),
          (async()=>{ try{ mapsJ   = await fetchJSON('/api/maps');   mapsOk   = true; }catch(e){ warn('maps fetch failed', e);   } })(),
        ]);

        if(robotsOk){ lastGoodRobots = robotsJ; updateRobots(robotsJ.robots || []); } else { updateRobots(lastGoodRobots.robots || []); }
        if(mapsOk){ lastGoodMaps = mapsJ; updateMaps(mapsJ); applyScaleToScene(); } else { updateMaps(lastGoodMaps); applyScaleToScene(); }
        // update path for active ns
        if(activeNs) fetchPathFor(activeNs);

        setStatus((robotsOk && mapsOk) ? ('ok ' + new Date().toLocaleTimeString()) : 'degraded');
      }

      window.addEventListener('load', ()=>{
        createMap();
        setupCameraDomInteractions();
        // Cameras: independent poller (parallel to UI tick)
        loadCameras();
        setInterval(loadCameras, 5000);   // every 5s; tune if needed
        // loops input for patrol
        const loopsInput = document.getElementById('loopsInput');

        // overlay alpha
        document.getElementById('opacity').addEventListener('input', (e)=>{
          overlayAlpha = parseFloat(e.target.value || '0.5'); applyOverlayAlpha();
        });

        // sizing slider
        const sizeEl = document.getElementById('size');
        const sizeVal = document.getElementById('sizeVal');
        const updateSize = ()=>{
          SIZE_SCALE = parseFloat(sizeEl.value || '1.0');
          sizeVal.textContent = `x${SIZE_SCALE.toFixed(1)}`;
          applyScaleToScene();
        };
        sizeEl.addEventListener('input', updateSize);
        updateSize();

        document.getElementById('btnCenterMap').addEventListener('click', ()=>{
          const overlayBounds=[], vertexPts=[];
          for(const m of (lastGoodMaps.maps || [])){
            if(m.overlay && m.overlay.bounds){
              const b=m.overlay.bounds;
              try{ overlayBounds.push(L.latLngBounds([b[0][0], b[0][1]], [b[1][0], b[1][1]])); }catch{}
            }
            if(Array.isArray(m.vertices)){ for(const v of m.vertices) vertexPts.push([v.lat, v.lon]); }
            if(Array.isArray(m.edges)){ for(const e of m.edges){ vertexPts.push([e.a.lat,e.a.lon],[e.b.lat,e.b.lon]); } }
          }
          if(!centerOnMaps(overlayBounds, vertexPts)) warn('center: nothing to fit');
        });

        document.getElementById('nsSelect').addEventListener('change', (e)=>{ activeNs = e.target.value || '/'; refreshCameraUI(); });


        document.getElementById('btnPublishPatrol').addEventListener('click', async ()=>{
          if(!activeNs) return alert('Select namespace');
          if(!selectedOrder.length) return alert('Select at least one vertex');

          let loops = 1;
          if (loopsInput) {
            const v = parseInt(loopsInput.value || '1', 10);
            if (!isNaN(v) && v > 0) loops = v;
          }

          try{
            await postJSON(
              `/api/${activeNs.replace(/^\//,'')}/patrol`,
              { sequence: selectedOrder, loops: loops }
            );
            showToast(`Patrol scheduled (loops: ${loops})`);
          }catch(e){
            alert('Patrol failed: ' + e.message);
          }
        });

        document.getElementById('btnClearSel').addEventListener('click', clearSelection);

        document.getElementById('btnCancelAll').addEventListener('click', async ()=>{
          if(!activeNs) return alert('Select namespace');
          try{ await postJSON(`/api/${activeNs.replace(/^\//,'')}/cancel_all`, {}); showToast('CancelAll sent'); }
          catch(e){ alert('CancelAll failed: ' + e.message); }
        });

        document.getElementById('btnReturnHome').addEventListener('click', async ()=>{
          if(!activeNs) return alert('Select namespace');
          try{ await postJSON(`/api/${activeNs.replace(/^\//,'')}/return_home`, {}); showToast('Return home sent'); }
          catch(e){ alert('Return home failed: ' + e.message); }
        });

        // ðŸ”´ IMPORTANT: draw immediately on first data
        tick();                 // <--- run first fetch/draw right now
        setInterval(tick, 1000);
      });

    </script>
  </body>
</html>
